#!/bin/bash
#
#	 NAME
#	   netwatcher
#
#	 DESCRIPTION
#	   This script is executed by the local.netwatcher LaunchAgent
#
#	   To read the defaults:
#	   defaults read ~/Library/LaunchAgents/local.netwatcher.plist
#
#	   To change a default key, use "defaults write <key> <value>"
#	   "man defaults" for more info
#
#	 AUTHOR
#	   Don Feliciano (don@effinthing.com)
#
#-------------------------------------------------------------------------------
# Constants
declare -r CONFIG_FILE=${HOME}/.netwatcher/config
declare -r LAST_MARKER=~/.netwatcher/last_known_network

#-------------------------------------------------------------------------------
# Globals
PAUSE_TO_SETTLE="y"
PAUSE_TIME=5
THROTTLE=5
HOME_NTP="time.apple.com"
VPN_NTP="10.91.92.1"
WORK_NTP=$(route -n get default | awk -F": " '/gateway/{ print $NF }')
WIFI_IF=""
ETHERNET_IF=""
BRIDGE_IF=""
VPN_IF=""
IP=""
VPN_IP=""
DOMAIN=""
SSID=""

#-------------------------------------------------------------------------------
# Load user configuration
#
[[ -r $CONFIG_FILE ]] || { printf "Cannot read ${CONFIG_FILE}.\n"; exit 1; }
source $CONFIG_FILE

#-------------------------------------------------------------------------------
# Functions
#
notify ()
{
	local title=$1
	local message=$2

	printf "${title}\n${message}\n"

	[[ -x /usr/local/bin/terminal-notifier ]] || return 0
	[[ $NOTIFICATION_CENTER == false ]] && return 0

	/usr/local/bin/terminal-notifier -title "$title" \
		-message "$message" -sound Pop
}

turn_on_airport ()
{
	local interface=$1
	/usr/sbin/networksetup -setairportpower $interface on
}

turn_off_airport ()
{
	local interface=$1
	/usr/sbin/networksetup -setairportpower $interface off
	sleep 5 # triggers another network_change
}

return_interface_status ()
{
	local interface=$1
	local status=$(/sbin/ifconfig $interface 2>/dev/null | awk '/status:/ { print $NF }')
	if [[ ! $status =~ active ]]; then
		status=inactive
	fi
	printf $status
}

get_ssid ()
{
	local interface=$1
	local ssid="$(/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I |\
		awk -F': ' '/^.* SSID/ { print $2 }')"
	printf "$ssid"
}

return_program_status ()
{
	local program=$1
	local status=$(pgrep -f "$program")
	if [[ $status == "" ]]; then
		printf "inactive"
	else
		printf "active"
	fi
}

quit_program ()
{
	local program=$1
	local friendly_name=$(echo $program | awk -F/ '{ print $NF }')
	
	printf "Stopping $friendly_name\n"
	pkill -f "$program" > /dev/null 2>&1
}

set_adium_status()
{
	local status=$1
	declare -i count
	local state=$(return_program_status "Adium")

	[[ $state == inactive ]] && open -a Adium
		
	printf "Changing Adium status"
	if [[ $status == Offline ]]; then
		/usr/bin/osascript <<- EOF
			tell application "System Events"
			if exists process "Adium" then
			tell application "Adium" to go offline account "$ADIUM_ACCOUNT"
			end if
			end tell
			EOF
	else
		/usr/bin/osascript <<- EOF
			tell application "System Events"
			if exists process "Adium" then
			tell application "Adium" to go online account "$ADIUM_ACCOUNT"
			tell application "Adium" to go away
			end if
			end tell
			EOF
	fi
	for (( count=5; count!=0; count-- )) { sleep 1 ; printf "."; }
	printf " $status\n"
}

set_default_printer()
{
	local printer=$1
	if [[ $printer != none ]] && [[ -n $printer ]]; then
		printf "Setting default printer: $printer\n"
		lpoptions -d $printer > /dev/null 2>&1
	fi
}

set_ntp_server()
{
	local ntp_server=$1
	local id=$(id -un)
	local mytemp=$(mktemp -t ${id}.xxxx)
	local pid
	declare -i nopasswd_all
	declare -i nopasswd_systemsetup
	declare -i count=0

	# If user is not in sudoers with "NOPASSWD: ALL" we can't
	# spawn sudo as it'll prompt for a password
	(sudo -l > "$mytemp" 2>&1) &
	pid=$!
	
	sleep 1

	grep -sqi 'NOPASSWD.*ALL' ${mytemp} 2>/dev/null
	nopasswd_all=$?

	grep -sqi 'NOPASSWD.*systemsetup' ${mytemp} 2>/dev/null
	nopasswd_systemsetup=$?

	if ( (( nopasswd_all == 0 )) || (( nopasswd_systemsetup == 0 )) ); then
		sudo systemsetup -setnetworktimeserver $ntp_server
	else
		printf "${id} does not have passwordless sudo access. NTP server cannot be changed.\n"
		# It's unlikely that "sudo -l" would prompt for a password or get stuck, but
		# just in case... although I'm not sure a regular user can even kill sudo?
		if pgrep -q -f sudo; then
			kill -9 $pid > /dev/null 2>&1
		fi
	fi

	rm -f "$mytemp"
}

print_dashes () {
	declare -i count
	declare -i num_dashes=$1
	for (( count=0; count!=num_dashes; count++ )) { printf %s '-'; }
}

switch_location ()
{
	local location=$1

	if [[ $location == work ]]; then
		if [[ $VPN_IP =~ [1-9] ]]; then
			notify "Location: Work" "IP: $VPN_IP"
		else
			notify "Location: Work" "IP: $IP"
		fi

		[[ $DROPBOX == true ]] && quit_program Dropbox	

		if [[ $PROXIFIER == true ]]; then	
			proxifier_status=$(return_program_status "Contents/MacOS/Proxifier")
			if [[ $proxifier_status == inactive ]]; then
				open -a "Proxifier"
				printf "Started Proxifier [ pid: $(pgrep -f 'Contents/MacOS/Proxifier') ]\n"
			fi
		fi
		
		if [[ $ORADOCS == true ]]; then
			oradocs_status=$(return_program_status "Oracle Content")
			if [[ $oradocs_status == inactive ]]; then
				open -a "Oracle Content"
				printf "Started Oracle Documents [ pid $(pgrep -f Oracle\ Content.app/Contents/MacOS/JavaAppLauncher)  ]\n"
			fi
		fi
	
		if [[ $VPN_IP =~ [1-9] ]]; then
			set_ntp_server "$VPN_NTP"
		else
			set_ntp_server "$WORK_NTP"
		fi
		
		set_default_printer "$WORK_PRINTER"
		set_adium_status "$ADIUM_WORK_STATUS"
	else
		if [[ $VPN_IP =~ [1-9] ]]; then
			notify "Location: Home" "IP: $VPN_IP"
		else
			notify "Location: Home" "IP: $IP"
		fi

		[[ $CISCO_ANYCONNECT == true ]] && quit_program "Cisco AnyConnect Secure Mobility Client"
		[[ $PROXIFIER == true ]] && quit_program "Proxifier"
		[[ $ORADOCS == true  ]] && quit_program "Oracle Content.app/Contents/MacOS/JavaAppLauncher"
		
		if [[ $DROPBOX == true ]]; then
			if [[ $(return_program_status "Dropbox") == inactive ]]; then
				open -a "Dropbox" && printf "Started Dropbox\n"
			fi
		fi

		set_ntp_server "$HOME_NTP"
		set_default_printer "$HOME_PRINTER"
		set_adium_status "$ADIUM_HOME_STATUS"
	fi
}

finish() {
	local last_config="$@"
	
	if [[ -n $last_config ]] && [[ $last_config != restart ]]; then
		printf "$last_config" > $LAST_MARKER
	elif [[ $last_config == restart ]]; then
		rm -f $LAST_MARKER
	else
		touch $LAST_MARKER
	fi

	printf %s%b $(print_dashes 60) "\n"
	exit 0
}

#-------------------------------------------------------------------------------
# Main script
#
#

# If -t is passed as an option than set as throttle limit
while getopts ":t:p:" OPTION; do
	case $OPTION in
		t) THROTTLE=$OPTARG ;;
		p) PAUSE_TO_SETTLE="y"
		   PAUSE_TIME=$OPTARG ;;
		?) ;;
	esac
done
shift $(( OPTIND-1 ))

# Purge log if it is megabyte(s)
log_file=$(defaults read /Users/${USER}/Library/LaunchAgents/local.netwatcher StandardOutPath)
log_size=$(du -k $log_file | awk '{print $1}')
if (( log_size > 1024 )); then
	: > $log_file
	printf "$(date '+%b %d %H:%M:%S'): Purged $log_file\n"
fi

# Log start of main logic
printf %b%s%b "\n" "$(print_dashes 20) $(date '+%b %d %H:%M:%S') $(print_dashes 21)" "\n"

# Exit if we ran less than $THROTTLE seconds ago
if [[ -r $LAST_MARKER ]]; then
	now=$(date +%s)
	last_update=$(stat -f %m $LAST_MARKER)
	if (( $(( now - last_update )) < THROTTLE )); then
		printf "Ran less than $THROTTLE seconds ago, exiting.\n"
		finish
	fi
fi

printf "Probing for [previously] configured interfaces...\n"
interfaces="$(/usr/sbin/networksetup -listnetworkserviceorder | grep [0-9]\)$ | sed -e s/^'(Hardware Port: '// -e s/\)// | sort)"
IFS=$(printf "\n\b")
for interface in $interfaces; do
	printf "	$interface\n"
	if [[ $interface =~ Bridge ]]; then
		BRIDGE_IF=$(printf $interface | awk '{ print $NF }')
	elif [[ $interface =~ Ethernet ]]; then
		ETHERNET_IF=$(printf $interface | awk '{ print $NF }')
	elif [[ $interface =~ Wi-Fi ]]; then
		WIFI_IF=$(printf $interface | awk '{ print $NF }')
	fi
done
unset IFS

# If we have an active bridge it trumps ethnernet interface
bridge_status=$(return_interface_status $BRIDGE_IF)
if [[ $bridge_status == active ]]; then
	$ETHERNET_IF=$BRIDGE_IF
fi

# See if we have an active VPN connection
printf "Probing for actively tunneled connections...\n"
(( count=0 ))
for utun_interface in $(ifconfig | grep -o '^utun[0-9].*:' | sed 's/://'); do
	VPN_IP=$(/sbin/ifconfig $utun_interface 2>/dev/null | grep 'inet ' | awk '{ print $2 }')
	if [[ $VPN_IP =~ [1-9] ]]; then
		printf "	$utun_interface: $VPN_IP\n"
		VPN_IF=$utun_interface
		(( count=count+1 ))
	fi
done

if (( count > 1 )); then
	printf "More than one utun interface with an IP. This is unexpected! Using $VPN_IF\n"
elif (( count == 0 )); then
	VPN_IF="none"
fi

# Make sure something is different than the last run (should always be the case, but...)
if [[ -r $LAST_MARKER ]]; then
	last_config="$(cat $LAST_MARKER)"
	if ifconfig -lu | grep -oq $VPN_IF; then
		if [[ "$last_config" == "$VPN_IF $(/sbin/ifconfig $VPN_IF | grep 'inet ' | awk '{ print $2 }')" ]]; then
			nothing_changed="true"
		fi
	else
		if [[ "$last_config" == "$WIFI_IF $(/usr/sbin/ipconfig getifaddr $WIFI_IF)" ]]; then
			ethernet_status=$(return_interface_status $ETHERNET_IF)
			if [[ $ethernet_status == inactive ]]; then
				nothing_changed="true"
			fi
		elif [[ "$last_config" == "$ETHERNET_IF $(/usr/sbin/ipconfig getifaddr $ETHERNET_IF)" ]]; then
			nothing_changed="true"
		fi
	fi
	
	if [[ $nothing_changed == true ]]; then
		printf "Nothing has changed. The active network is still: $last_config\n"
		finish
	fi
fi

if [[ $PAUSE_TO_SETTLE == y ]]; then
   printf "Pausing $PAUSE_TIME seconds to let interfaces settle... "
   for (( count=$PAUSE_TIME; count!=0; count-- )) { sleep 1 ; printf "$count "; }
   printf "\n"
fi

# VPN trumps everything
VPN_IP=$(/sbin/ifconfig $VPN_IF 2>/dev/null | grep 'inet ' | awk '{ print $2 }')
if [[ $VPN_IP =~ [1-9] ]]; then
		if grep -qs oracle /etc/resolv.conf ; then
			switch_location "work"
		else
			switch_location "home"
		fi
		finish "$VPN_IF" "$VPN_IP"
fi

# Ethernet trumps Wi-Fi no matter what
if [[ $ETHERNET == true ]] && [[ -n $ETHERNET_IF ]]; then
	printf "Checking link status for $ETHERNET_IF (ethernet)..."
	ethernet_status=$(return_interface_status $ETHERNET_IF)
	(( count=0 )) # If cable was just plugged-in we need time for DHCP to do its thing
	while [[ $ethernet_status != active ]] && (( count != 5 )); do
		sleep 1
		printf "."
		ethernet_status=$(return_interface_status $ETHERNET_IF)
		(( count++ ))
	done
	printf " $ethernet_status\n"
	
	if [[ $ethernet_status == active ]]; then
		printf "Fetching IP and domain info for $ETHERNET_IF (ethernet)..."
		IP=$(/usr/sbin/ipconfig getifaddr $ETHERNET_IF)
		(( count=0 ))
		while [[ ! $IP =~ [1-9] ]] && (( count != 15 )); do
			sleep 1
			printf "."
			IP=$(/usr/sbin/ipconfig getifaddr $ETHERNET_IF)
			(( count++ ))
		done
		
		DOMAIN=$(/usr/sbin/ipconfig getoption $ETHERNET_IF domain_name)
		
		if [[ $IP =~ [1-9] ]]; then
			if [[ $IP =~ $WORK_IP_PATTERN ]] || [[ $DOMAIN =~ $WORK_DOMAIN_PATTERN ]]; then
				switch_location "work"
			else
				switch_location "home"
			fi
			printf "On ethernet, turning off Wi-Fi... "
			turn_off_airport $WIFI_IF
			printf "DONE\n"
			finish "$ETHERNET_IF $IP"
		else
			printf " timed out\n"
		fi
	fi
fi

# If no ethernet, try Wi-Fi
printf "Checking link status for $WIFI_IF (Wi-Fi)..."
wifi_status=$(return_interface_status $WIFI_IF)
printf " $wifi_status\n"

# Turning of Wi-Fi will trigger a separate LaunchAgent, so we exit
# and let this script get run again from the top
if [[ $wifi_status == inactive ]]; then
	notify "$WIFI_IF $wifi_status" "Turning on Wi-Fi"
	printf "Turning on Wi-Fi... "
	turn_on_airport $WIFI_IF
	printf "DONE\n"
	finish restart
fi

# TODO (?) - accept a hash of known SSIDs and their respective prefs, then
# act accordingly. Too much work for me as I see no action necessary
# for a public hotspot beyond killing off Proxifier and the else clause
# below does that

# Okey dokey. By now we should have associated with a Wi-Fi network
IP=""
SSID="$(get_ssid $WIFI_IF)"
if [[ -n $SSID ]]; then
	IP=$(/usr/sbin/ipconfig getifaddr $WIFI_IF)
	DOMAIN=$(/usr/sbin/ipconfig getoption $WIFI_IF domain_name)
	if [[ $IP =~ [1-9] ]]; then
		if [[ $SSID =~ $WORK_SSID ]] || [[ $DOMAIN =~ $WORK_DOMAIN_PATTERN ]]; then
			switch_location "work"
		elif [[ $SSID =~ $HOME_SSID ]] || [[ $DOMAIN =~ $HOME_DOMAIN_PATTERN ]]; then
			switch_location "home"
		else
			notify "SSID: $SSID" "IP: $IP"
			quit_program "Cisco AnyConnect Secure Mobility Client"
			quit_program "Proxifier"
			quit_program "Oracle Content.app/Contents/MacOS/JavaAppLauncher"
		fi
	fi
else
	notify "Timeout" "No known networks responded in time"
fi

finish "$WIFI_IF" "$IP"
